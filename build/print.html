<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Hello</a></li><li class="chapter-item expanded "><a href="history.html"><strong aria-hidden="true">2.</strong> History</a></li><li class="chapter-item expanded "><a href="why_rust.html"><strong aria-hidden="true">3.</strong> Why Rust</a></li><li class="chapter-item expanded "><a href="rustup_and_cargo.html"><strong aria-hidden="true">4.</strong> Rustup and Cargo</a></li><li class="chapter-item expanded "><a href="crates.html"><strong aria-hidden="true">5.</strong> Crates</a></li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">6.</strong> Modules</a></li><li class="chapter-item expanded "><a href="basic_types.html"><strong aria-hidden="true">7.</strong> Basic types</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">8.</strong> Functions</a></li><li class="chapter-item expanded "><a href="structures.html"><strong aria-hidden="true">9.</strong> Structs</a></li><li class="chapter-item expanded "><a href="enums.html"><strong aria-hidden="true">10.</strong> Enums</a></li><li class="chapter-item expanded "><a href="immutability.html"><strong aria-hidden="true">11.</strong> Immutability</a></li><li class="chapter-item expanded "><a href="safety.html"><strong aria-hidden="true">12.</strong> Safety</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="safety/ownership_borrowing.html"><strong aria-hidden="true">12.1.</strong> Ownership and borrowing</a></li><li class="chapter-item expanded "><a href="safety/ownership_borrowing2.html"><strong aria-hidden="true">12.2.</strong> Ownership and borrowing 2</a></li><li class="chapter-item expanded "><a href="safety/ownership_lifetimes.html"><strong aria-hidden="true">12.3.</strong> Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="traits.html"><strong aria-hidden="true">13.</strong> Traits</a></li><li class="chapter-item expanded "><a href="pattern_matching.html"><strong aria-hidden="true">14.</strong> Pattern matching</a></li><li class="chapter-item expanded "><a href="pattern_matching2.html"><strong aria-hidden="true">15.</strong> Pattern matching</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">16.</strong> Generics</a></li><li class="chapter-item expanded "><a href="std.html"><strong aria-hidden="true">17.</strong> STD</a></li><li class="chapter-item expanded "><a href="option.html"><strong aria-hidden="true">18.</strong> Option</a></li><li class="chapter-item expanded "><a href="result.html"><strong aria-hidden="true">19.</strong> Result</a></li><li class="chapter-item expanded "><a href="error_handling.html"><strong aria-hidden="true">20.</strong> Error handling</a></li><li class="chapter-item expanded "><a href="iterators.html"><strong aria-hidden="true">21.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">22.</strong> Macros</a></li><li class="chapter-item expanded "><a href="async_await.html"><strong aria-hidden="true">23.</strong> Async/Await</a></li><li class="chapter-item expanded "><a href="end.html"><strong aria-hidden="true">24.</strong> End?</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-programming-language"><a class="header" href="#rust-programming-language">Rust programming language</a></h1>
<p>Ferris says Hi!</p>
<p><img src="media/ferris.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="history"><a class="header" href="#history">History</a></h1>
<ul>
<li>
<p>Started in 2006 by Graydon Hoare at Mozilla.</p>
</li>
<li>
<p>First announced in 2010</p>
<ul>
<li>Primary goals: a fast and secure expression oriented language (you can pick any two)</li>
<li>Parts of Firefox are written in Rust</li>
<li>most admired programming language, making it the most loved language for 8 years in a row</li>
</ul>
</li>
<li>
<p>First stable release in 2015</p>
<ul>
<li>New releases every 6 weeks, “edition 2021” released in Oct '21</li>
</ul>
</li>
<li>
<p>Who uses it?</p>
<ul>
<li>AWS: Firecracker powers Lambda and Fargate</li>
<li>Google: parts of the Fuchsia operating system</li>
<li>Linux: 2nd official language for the Kernel!</li>
<li>Dropbox: file storage</li>
<li>Growing ecosystem for embedded development</li>
<li>Microsoft - Windows 11</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-rust"><a class="header" href="#why-rust">Why Rust?</a></h1>
<p>The main purpose of using Rust is enhanced safety, speed, and concurrency, or the ability to run multiple computations parallelly. In simple words, Rust is used for three essential purposes in programming; 
performance, safety, and memory management</p>
<h2 id="zero-cost-abstractions"><a class="header" href="#zero-cost-abstractions">Zero-cost abstractions</a></h2>
<p>Rust is a low-level language that provides zero-cost abstractions. 
It means that Rust provides the same level of control as C and C++ but without the risk of memory leaks and segmentation faults.
These abstractions are implemented and enforced by the compiler, but don't add any overhead to the runtime of your program.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-rustup--cargo"><a class="header" href="#getting-started-rustup--cargo">Getting started: rustup &amp; cargo</a></h1>
<h2 id="rustup-the-rust-toolchain-manager"><a class="header" href="#rustup-the-rust-toolchain-manager">Rustup: the Rust toolchain manager</a></h2>
<p>Manage versions, target OS and architectures</p>
<pre><code class="language-shell">  curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>or download from https://rustup.rs/</p>
<p><code>rustup doc --std</code> -- browse the docs locally!</p>
<h2 id="cargo-the-rust-build-system"><a class="header" href="#cargo-the-rust-build-system">Cargo: the Rust build system</a></h2>
<pre><code class="language-shell">cargo new --bin rust_intro
cargo run
</code></pre>
<pre><code class="language-shell">.
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="package-registry"><a class="header" href="#package-registry">Package registry</a></h1>
<p>All packages are exposed at <a href="http://crates.io">crates.io</a>, currently there are over
120.000 packages available.</p>
<p>We are using packages from crates.io as dependencies of our projects, but you can also share your code with other people by publishing your own packages. The crate registry at crates.io distributes the source code of your packages, so it primarily hosts code that is open source.</p>
<p><img src="media/crates.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>Rust provides a powerful module system that can be used to hierarchically split code in logical units (modules), and manage visibility (public/private) between them.</p>
<p>A module is a collection of items: functions, structs, traits, impl blocks, and even other modules.</p>
<pre><code class="language-shell">.
├── Cargo.toml
└── src
    └── lib.rs
    └── module
      └── mod.rs
      └── hello.rs
</code></pre>
<p>In mod.rs we need to add <code>pub mod hello;</code> to make it visible to the outside world.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod hello;
<span class="boring">}</span></code></pre></pre>
<p>Also in lib.rs we need to have</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod module;
<span class="boring">}</span></code></pre></pre>
<p>You can also provide modules directly in rust file</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod hello {
    pub fn world() {
        println!(&quot;Hello, world!&quot;);
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-types"><a class="header" href="#basic-types">Basic types</a></h1>
<p>Rust provides basic types similar to other programming languages:</p>
<ul>
<li>signed integers: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>isize</code></li>
<li>unsigned integers: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code></li>
<li>floating point: <code>f32</code>, <code>f64</code></li>
<li>boolean: <code>bool</code></li>
<li>strings: <code>&amp;str</code> and <code>String</code> (we have way to many string types)</li>
<li>structs: <code>struct</code></li>
<li>tuples: <code>tuple</code></li>
<li>enums: <code>enum</code></li>
<li>arrays: <code>[T; N]</code></li>
<li>unit type: <code>()</code></li>
</ul>
<p>Type inference is a feature of Rust that allows the compiler to determine the type of a value based on the context in
which it is used. This means that, in many cases, you don't need to explicitly specify the type of a variable or
function parameter.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Because of the annotation, the compiler knows that `elem` has type u8.
    let elem = 5u8;

    // Create an empty vector (a growable array).
    let mut vec = Vec::new();
    // At this point the compiler doesn't know the exact type of `vec`, it
    // just knows that it's a vector of something (`Vec&lt;_&gt;`).

    // Insert `elem` in the vector.
    vec.push(elem);
    // Aha! Now the compiler knows that `vec` is a vector of `u8`s (`Vec&lt;u8&gt;`)
    // TODO ^ Try commenting out the `vec.push(elem)` line

    println!(&quot;{:?}&quot;, vec);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions are declared using the fn keyword. Its arguments are type annotated, just like variables, and, if the function
returns a value, the return type must be specified after an arrow -&gt;.</p>
<p>The final expression in the function will be used as return value. Alternatively, the return statement can be used to
return a value earlier from within the function, even from inside loops or if statements.</p>
<p>Rust code uses snake case as the conventional style for function and variable names, in which all letters are lowercase
and underscores separate words.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

// Example of generic function
pub fn print&lt;T: Debug&gt;(input: T) {
    println!(&quot;{:?}&quot;, input);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structures"><a class="header" href="#structures">Structures</a></h1>
<p>There are three types of structures (&quot;structs&quot;) that can be created using the struct keyword:</p>
<ul>
<li>Tuple structs, which are, basically, named tuples.</li>
<li>The classic C structs</li>
<li>Unit structs, which are field-less, are useful for generics.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Default)]
#[repr(C)]
struct Person {
    name: String,
    age: u8,
}

// A unit struct
struct Unit;

// A tuple struct
struct Pair(i32, f32);
<span class="boring">}</span></code></pre></pre>
<p>Implementations of structs</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Person {
    fn new(name: String) -&gt; Val {
        Person {
            name,
            ..Default::default()
        }
    }
    fn set_name(&amp;mut self, name: String) -&gt; &amp;f64 {
        &amp;self.name = name;
    }
    fn print_name(&amp;self) {
        println!(&quot;Name: {}&quot;, self.name);
    }
    fn into_string(self) -&gt; String {
        format!(&quot;Hello {}, age: {}&quot;, self.name, self.age)
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p>An enum in Rust is a type that represents data that is one of several possible variants. Each variant in the enum can
optionally have data associated with it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Message {
    Quit,
    ChangeColor(i32, i32, i32),
    Move { x: i32, y: i32 },
    Write(String),
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="immutability-by-default"><a class="header" href="#immutability-by-default">Immutability by default</a></h1>
<p>Rust variables are immutable by default</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = 42;
hello = 43;
<span class="boring">}</span></code></pre></pre>
<p>We need to explicitly mark variable as mutable by using <code>mut</code> keyword</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut sum = 0;
    for i in 0..5 {
        sum += i;
    }
    println!(&quot;sum is {}&quot;, sum);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-safety"><a class="header" href="#memory-safety">Memory safety</a></h1>
<p>Rust's approach to memory safety is based on two key concepts: ownership and borrowing. 
These concepts are enforced by Rust's compiler and prevent common memory-related bugs like null pointers, use-after-free errors, and buffer overflows.
Ownership is Rust’s most unique feature and has deep implications for the rest of the language. It enables Rust to make memory safety guarantees without needing a garbage collector, so it’s important to understand how ownership works.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-and-borrowing"><a class="header" href="#ownership-and-borrowing">Ownership and borrowing</a></h1>
<p>Ownership is Rust’s most unique feature and has deep implications for the rest of the language. It enables Rust to make memory safety guarantees without needing a garbage collector, so it’s important to understand how ownership works.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// name argument is now owned by print_name function
fn print_name(name: String) {
    println!(&quot;Hello, {}!&quot;, name);
}

// prepare name variable
let name = &quot;Peter&quot;.to_string();

// now we pass ownership to print_name function
print_name(name);

// This will not compile
println!(&quot;{}&quot;, name);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-and-borrowing-2"><a class="header" href="#ownership-and-borrowing-2">Ownership and borrowing 2</a></h1>
<p>We can borrow given string so we can use it after function returns back</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// name 
fn print_name(name: &amp;String) {
    println!(&quot;Hello, {}!&quot;, name);
}

// prepare name variable
let name = &quot;Peter&quot;.to_string();

// now we pass ownership to print_name function
print_name(&amp;name);

// This will not compile
println!(&quot;{}&quot;, name);
<span class="boring">}</span></code></pre></pre>
<p>With mutable borrows we can even modify borrowed variable</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_name(name: &amp;mut String) {
    name.push_str(&quot;!&quot;);
}

// prepare name variable
let mut name = &quot;Peter&quot;.to_string();

// now we pass ownership to print_name function
update_name(&amp;mut name);

// This will not compile
println!(&quot;{}&quot;, name);

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h1>
<p>A lifetime is a construct of the compiler (or more specifically, its borrow checker) uses to ensure all borrows are
valid. Specifically, a variable's lifetime begins when it is created and ends when it is destroyed. While lifetimes and
scopes are often referred to together, they are not the same.</p>
<p>Take, for example, the case where we borrow a variable via &amp;. The borrow has a lifetime that is determined by where it
is declared. As a result, the borrow is valid as long as it ends before the lender is destroyed. However, the scope of
the borrow is determined by where the reference is used.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest&lt;'a&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<p>A trait defines functionality a particular type has and can share with other types. We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic type can be any type that has certain behavior.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
<span class="boring">}</span></code></pre></pre>
<p>There are a lot of traits in the standard library. For example, </p>
<ul>
<li><code>ToString</code> trait is implemented by any type that can be converted into a <code>String</code> value. We can use the <code>to_string</code> method defined by the <code>ToString</code> trait to convert a number into a <code>String</code>:</li>
<li><code>Into</code> trait is implemented by any type that can be converted into another type. </li>
<li><code>From</code> trait is implemented by any type that can be created from another type.</li>
<li><code>Debug</code> trait is used to format a value using the <code>{:?}</code> formatter.</li>
<li><code>std::ops</code> module contains traits for overloading operators.</li>
</ul>
<p>Some traits can be implemented by deriving them. For example, the <code>Debug</code> trait can be implemented by deriving it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct Point {
    x: i32,
    y: i32,
}
<span class="boring">}</span></code></pre></pre>
<p>This means that they use derive macros to generate the implementation. We can also implement traits manually:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Point {
    x: i32,
    y: i32,
}

impl Debug for Point {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt; {
        write!(f, &quot;Point {{ x: {}, y: {} }}&quot;, self.x, self.y)
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern matching</a></h1>
<p>Patterns are a special syntax in Rust for matching against the structure of types, both complex and simple. Using patterns in conjunction with match expressions and other constructs gives you more control over a program’s control flow.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let v = vec![10, 20, 30];
    let idx = 0;

    match v.get(idx) {
        Some(value) =&gt; println!(&quot;Value is {}&quot;, value),
        None =&gt; println!(&quot;No value...&quot;),
    }
}</code></pre></pre>
<p>Even more advanced pattern matching</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let n = 0;
    let text = match n {
        0 =&gt; &quot;zero&quot;,
        1 =&gt; &quot;one&quot;,
        2 =&gt; &quot;two&quot;,
        _ =&gt; &quot;many&quot;,
    };

    println!(&quot;{} is {}&quot;, n, text);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-matching-2"><a class="header" href="#pattern-matching-2">Pattern matching 2</a></h1>
<p>Every pattern matching must be exhaustive (all possible cases must be covered).
Lets see an enum example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Color {
    Red,
    Green,
    Blue,
}

let color = Color::Red;

let name = match color {
    Color::Red =&gt; &quot;red&quot;,
    Color::Green =&gt; &quot;green&quot;,
};


<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<p>We use generics to create definitions for items like function signatures or structs, which we can then use with many different concrete data types.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Hello&lt;T&gt; {
    pub message: T,
}
<span class="boring">}</span></code></pre></pre>
<p>We will explore them in next slides.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-library"><a class="header" href="#standard-library">Standard library</a></h1>
<p>The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the broader Rust ecosystem. It offers core types
Such as <code>Vector</code>, <code>Option</code>, <code>Result</code>, and <code>String</code>, library-defined operations on language primitives, standard macros, I/O and multithreading, among many other things.</p>
<p>Some modules that are in std lib are:</p>
<ul>
<li><code>std::collections</code> - Collection types.</li>
<li><code>std::fs</code> - Filesystem</li>
<li><code>std::io</code> - Input/Output</li>
<li><code>std::net</code> - Networking</li>
<li><code>std::process</code> - Processes</li>
<li><code>std::thread</code> - Threads</li>
<li><code>std::time</code> - Time</li>
<li><code>std::path</code> - Path manipulation</li>
<li><code>std::env</code> - Environment variables</li>
<li><code>std::error</code> - Interfaces for working with Errors</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optiont"><a class="header" href="#optiont"><code>Option&lt;T&gt;</code></a></h1>
<p>Option type is a type that represents an optional value. It is either <code>Some(value)</code> or <code>None</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type Option&lt;T&gt; {
    pub Some(T),
    pub None
}
<span class="boring">}</span></code></pre></pre>
<p>Pattern matching is a way to extract data from an Option.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Some(5);

match x {
    Some(i) =&gt; println!(&quot;i = {}&quot;, i),
    None =&gt; println!(&quot;no value&quot;),
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resultt-e"><a class="header" href="#resultt-e"><code>Result&lt;T, E&gt;</code></a></h1>
<p>Result type represent either success (<code>Ok</code>) or failure (<code>Err</code>).
It provides a lot of useful methods to inspect it. We can use pattern matching to extract data from a <code>Result</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result: Result&lt;i32, ()&gt; = Ok(5);

match result {
    Ok(i) =&gt; println!(&quot;i = {}&quot;, i),
    Err(_) =&gt; println!(&quot;no value&quot;),
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h1>
<p>Matching on result (and option) is nice, but it would be tedious to write this code every time we want to extract data from a <code>Result</code>.
That's where <code>?</code> operator comes in handy.</p>
<pre><pre class="playground"><code class="language-rust editable">pub fn process() -&gt; Result&lt;String, String&gt; {
    Ok(&quot;ok&quot;.to_string())
}

pub fn outer() -&gt; Result&lt;String, String&gt; {
    let result = process()?;
    Ok(result)
}</code></pre></pre>
<p><code>?</code> operator can be used only in functions that return <code>Result</code> or <code>Option</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterators-and-cosures"><a class="header" href="#iterators-and-cosures">Iterators and Cosures</a></h1>
<p>Rust’s design has taken inspiration from many existing languages and techniques, and one significant influence is
functional programming. Programming in a functional style often includes using functions as values by passing them in
arguments, returning them from other functions, assigning them to variables for later execution, and so forth.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
println!(&quot;Got: {}&quot;, val);
}
<span class="boring">}</span></code></pre></pre>
<p>Or even more complicated use of iterator</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = (1..10)
    .map(|x| x + 1)
    .filter(|x| x % 2 == 0)
    .map(|x| x.to_string())
    .collect::&lt;Vec&lt;_&gt;&gt;();
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<p>Rust macros are a powerful tool that allow you to write code that writes code. Macros are used to extend the language itself. They are similar to C/C++ macros, but they are much more powerful and safer.
We call them hygienic macros because they are designed to prevent unintended side-effects and bugs.</p>
<p>There are multiple types of macros in Rust:</p>
<ul>
<li>Declarative macros with <code>macro_rules!</code> syntax</li>
<li>Procedural macros
<ul>
<li>Custom <code>#[derive]</code> macros</li>
<li>Attribute-like macros</li>
<li>Function-like macros</li>
</ul>
</li>
</ul>
<p>This solves some of rust limitations. They are powerful and can be used to extend the language itself.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asyncawait"><a class="header" href="#asyncawait">Async/Await</a></h1>
<p>Even that rust provides fearless concurrency, it's not always the best choice to use multithreading.
Rust provides async await keywords support to write asynchronous code.
It does not provide actual implementation of async runtime, but it provides all necessary tools to write asynchronous code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="end"><a class="header" href="#end">End</a></h1>
<p>So you reached the end of my presentation.</p>
<p>But this is not all. There is way more to Rust than I could cover in this presentation.
I hope you will give it a try and maybe even use it in your next project.</p>
<p>This presentation will be available on my github account, so you can check it out later.</p>
<p>Links:</p>
<ul>
<li><a href="">https://www.rust-lang.org/</a> - Rust Homepage</li>
<li><a href="">https://doc.rust-lang.org/book/</a> - The Book</li>
<li><a href="">https://doc.rust-lang.org/rust-by-example/</a> - Rust by Example</li>
<li><a href="">https://rust-unofficial.github.io/too-many-lists/</a> - Too Many Lists</li>
<li><a href="">https://www.reddit.com/r/rust/</a> - Rust Subreddit</li>
<li><a href="">https://play.rust-lang.org/</a> - Rust Playground</li>
<li><a href="">https://libs.rs/</a> - Rust Libraries</li>
<li><a href="">https://crates.io/</a> - Rust Crates</li>
<li><a href="">https://tokio.rs/</a> - Tokio</li>
<li><a href="">https://github.com/rust-lang/rustlings</a> - Rustlings</li>
<li><a href="">https://doc.rust-lang.org/nomicon/</a> - The Rustonomicon</li>
<li><a href="">https://github.com/rust-lang/rust-bindgen</a> - Rust Bindgen</li>
<li><a href="">https://cxx.rs/</a> - CXX</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>


        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
